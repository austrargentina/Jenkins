Task
====

The project is divided in two parts.

* Basic and

* Advanced

Basic
-----

Implement a simple-to-use application to monitor and configure a hardware firewall appliance “Juniper NetScreen 5GT “. The firewall allows read access over the SNMP-protocol (your app should be able to test if SNMPv3 is available and if no fallback on SNMPv2c) and write access over Telnet.

Your app should accomplish following tasks:

* List all configured firewall rules (policies) on the device, add the details of the mentioned services and zones as well

* Allow refreshing of the list by clicking a button and by a configurable time-intervall. Your GUI should remain responsive even with short refresh-intervals!

* Visualize the thru-put for a highlighted firewall-rule (nice2have: multiple rows) in a line-chart (configurable refresh-interval, unit bytes/sec)

* Encapsulate the data retrieval for further reuse and easy expansion. An UML-model of your design will help you defend it at the review!

* Build a visual appealing and easy to use interface (there is more than Swing out there).

Advanced
--------

Additionally to the basic tasks your app should accomplish the following:

* Alarm the user visually and per email if the config of the firewall-rules changes. To avoid polling use the SNMP-trap mechanism.

* Allow managing of firewall-rules (CRUD). To accomplish this, you will have to send configuration commands via telnet or ssh. An admin-account is available per request.

* Use multicast-groups to build a simple transaction system to serialize administrative tasks on the firewall (for example pass an “admin token” to recognize the collaborator who is allowed to write to the firewall). This should also work in a heterogenous environment (different implementations, different OSes), so you have to coordinate with other teams.

* Make sure, that your interface to the firewall allows an easy change of the firewall-model (new releases, manufacturer, ...). It is not necessary to make this configurable in the GUI but must (explicitly) be considered in your software-design!

Teams
-----

Build teams with 3 to 5 participants (5 only if two or more members choose advanced level and at least one member chooses basic level). Each individual team-member has to implement, test and document code and is allowed to choose the level of difficulty he/she wants to achieve. For example: if you have a group of four students and two of them want to achieve advanced level, they can focus their implementation work on the advanced tasks. The other two team-members focus on the basic functionality. In any case there must be a working product, advanced tasks can not stand for themselves


Grading
-------

A team can apply for submission with a (mostly) functional product.

Each team-member will be graded separately, based on the documentation (and git-logs) which name him/her as author in all three main competencies as listed.

Advanced tasks will only be considered if the basic tasks are fulfilled for the most part in this team.

